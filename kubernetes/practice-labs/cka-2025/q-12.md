# ‚úÖ **Q-12 ‚Äî Recreate MariaDB Deployment Using Existing PV (CKA-2025)**

## **First, understand the question**

The question says:

* The **MariaDB Deployment** was deleted.
* But the **PersistentVolume (PV)** STILL exists.
* That PV already has your **database data**.
* You must:

  1. Create a **PVC** that binds to that PV.
  2. Edit the provided file `~/mariadb-deploy.yaml` to attach that PVC.
  3. Apply it.
  4. Ensure database comes up and becomes stable.

---

# ‚úÖ **Trap #1 ‚Äî You MUST reuse the existing PV**

They wrote:

> ‚ÄúA PersistentVolume already exists and is retained for reuse. Only one PV exists.‚Äù

Meaning:

* You **cannot create a new PV**
* You **must bind to the existing one**
* PVC *must* match:

  * `storageClassName` (if the PV uses one OR is empty)
  * `accessModes`
  * `capacity` (PVC ‚â§ PV)

---

# ‚úÖ **Trap #2 ‚Äî PVC MUST bind successfully**

So you must check:

```bash
kubectl get pv
```

Example PV might look like:

```yaml
capacity:
  storage: 250Mi
accessModes:
- ReadWriteOnce
storageClassName: manual
```

Your PVC *must match this exactly*.

---

# ‚úÖ **Trap #3 ‚Äî Deployment must point to the PVC, NOT a hostPath**

Some candidates mistakenly patch:

```yaml
hostPath:
```

But here the database will NOT recover data.

You MUST use the PVC.

---

# ‚≠ê **Step-by-step solution (What YOU will do in exam)**

---

## **STEP 1 ‚Äî Check the PV**

```bash
kubectl get pv
kubectl describe pv <pv-name>
```

Note the values:

* storage capacity
* accessModes
* storageClassName

---

## **STEP 2 ‚Äî Create PVC named `mariadb` in namespace `mariadb`**

Create the file:

```bash
kubectl create ns mariadb  # only if NS does not exist
```

```bash
kubectl create -n mariadb -f - <<EOF
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mariadb
  namespace: mariadb
spec:
  volumeName: <>            # put the pv name here, mandatory
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 250Mi
  storageClassName: manual    # IF PV has this
EOF
```

üí° *If PV has empty storageClassName, you must remove this line.*

---

## **STEP 3 ‚Äî Edit the Deployment (~/mariadb-deploy.yaml)**

Open the file:

```bash
vi ~/mariadb-deploy.yaml
```

Add under `spec.template.spec.containers.volumeMounts`:

```yaml
volumeMounts:
- name: mariadb-storage
  mountPath: /var/lib/mysql
```

Add under `spec.template.spec.volumes`:

```yaml
volumes:
- name: mariadb-storage
  persistentVolumeClaim:
    claimName: mariadb
```

---

## **STEP 4 ‚Äî Apply the deployment**

```bash
kubectl apply -f ~/mariadb-deploy.yaml
```

---

## **STEP 5 ‚Äî Verify**

```bash
kubectl get pods -n mariadb
kubectl describe pod -n mariadb <pod-name>
kubectl get pvc -n mariadb
kubectl get pv
```

PVC status must be:

```
Bound
```

Pod must be:

```
Running
Ready
```

---

# ‚úÖ **COMPLETE FINAL YAML (What your Deployment must look like)**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mariadb
  namespace: mariadb
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mariadb
  template:
    metadata:
      labels:
        app: mariadb
    spec:
      containers:
      - name: mariadb
        image: mariadb:10.6
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: mypass
        volumeMounts:
        - name: mariadb-storage
          mountPath: /var/lib/mysql

      volumes:
      - name: mariadb-storage
        persistentVolumeClaim:
          claimName: mariadb
```

---

# ‚≠ê EXAM NOTES (Add to your notebook)

### ‚úî If PV exists ‚Üí NEVER create a new PV

### ‚úî PVC must match PV‚Äôs:

* StorageClass
* AccessModes
* Capacity

### ‚úî If you mismatch ‚Üí PVC stays **Pending ‚Üí Pod fails ‚Üí You lose marks**

### ‚úî Deployment must mount the PVC to the correct MariaDB data path:

```
/var/lib/mysql
```

### ‚úî After applying ‚Üí ALWAYS check:

```
get pv
get pvc
get pods
```

---
