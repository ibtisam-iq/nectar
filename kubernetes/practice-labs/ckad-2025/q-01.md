## Question - 1

You need to scale an existing deployment for availability and create a service to expose the deployment within your infrastructure.
**Task:**

* Start with the deployment named `nov2025-deployment` which has already been deployed to the namespace `nov2025`.
* Add the key/value label `func=webFrontend` to the pod template metadata to identify the pods for the service definition.
* Have **4 replicas**.
* Next, create and deploy in namespace `nov2025` a **Service** that accomplishes the following:

  * Is of type **NodePort**, and name **Berry**
  * Exposes the service on **TCP port 8080**
  * Mapped to pods defined by the specification of `nov2025-deployment`

---

## ðŸš¨ Common Mistakes / Traps

* Changing the Deployment **selector** instead of only adding a label to the pod template â€” this can break the Deployment (pods may not be recognized).
* Using the wrong label in Service selector â€” e.g., selecting `app=nov2025-app` when you changed the label or selecting an incorrect label (`func=webFrontend`) mistakenly while pods donâ€™t have it.
* Forgetting to add the new label to the pod template (so Service selector fails).
* Forgetting to set replicas to 4 (exam may count it as failure).
* Incorrect port mapping (e.g., specifying service port 80 instead of 8080).
* Creating Service in wrong namespace.
* Using `ClusterIP` instead of `NodePort`.
* Not verifying Service `NodePort` exists or is reachable.

---

## ðŸ§­ Step-by-step Solution Logic

1. `kubectl edit deployment nov2025-deployment -n nov2025` (or export, modify YAML)
2. In `spec.template.metadata.labels`, add `func: webFrontend`
3. In the same Deployment, modify `spec.replicas: 4`
4. Save changes â†’ check rollout status: `kubectl rollout status deployment/nov2025-deployment -n nov2025`
5. Create a Service manifest named `Berry` in namespace `nov2025`, type NodePort, port 8080, selector `func=webFrontend`. (Ensure `targetPort` set to container port of pods; assume 8080 unless other given).
6. Apply the Service: `kubectl apply -f service-berry.yaml`
7. Verify Service: `kubectl get svc Berry -n nov2025` â†’ check `Type: NodePort`, `Port: 8080/TCP`, `NodePort: <someport>`
8. Verify pods: `kubectl get pods -n nov2025 -l func=webFrontend` â†’ should return 4 pods
9. Test connectivity (if permitted): from a node: `curl <NodeIP>:<NodePort>` and expect HTTP response
10. Confirm everything is ready and matches requirements.

---

## ðŸ–‹ Kubectl Commands

```bash
kubectl -n nov2025 edit deployment nov2025-deployment

kubectl -n nov2025 rollout status deployment/nov2025-deployment

kubectl expose deploy nov2025-deployment --type NodePort --port 8080 --selector func=webFrontend -n nov2025

kubectl -n nov2025 get svc Berry
kubectl -n nov2025 get pods -l func=webFrontend

# optional connectivity test:
# curl http://<node-ip>:<nodePort>
```

---

## ðŸ“„ Final YAML (exam-ready)

**Deployment (modified)**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nov2025-deployment
  namespace: nov2025
spec:
  replicas: 4
  selector:
    matchLabels:
      app: nov2025-app
  template:
    metadata:
      labels:
        app: nov2025-app
        func: webFrontend
    spec:
      containers:
        - name: nov2025-container
          image: nginx
          ports:
            - containerPort: 8080
```

**Service (NodePort)**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: Berry
  namespace: nov2025
spec:
  type: NodePort
  selector:
    func: webFrontend
  ports:
    - protocol: TCP
      port: 8080
      targetPort: 8080
```

---
