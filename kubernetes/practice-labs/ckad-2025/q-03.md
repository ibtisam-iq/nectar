# **CKAD â€“ Q03 (Question Statement)**

### **Task:**

Please complete the following:

1. **Update the `app` Deployment** in the **`nov2025` namespace** with:

   * `maxSurge: 5%`
   * `maxUnavailable: 5%`

2. **Perform a rolling update** of the **`web1` Deployment**,
   changing the image version to **`repo/nginx:1.13`**

3. **Rollback the `app` Deployment** to the **previous version**

---

# **ğŸ“Œ What the Question Is Asking**

You are given a Deployment with:

* A rolling update strategy
* An image that needs to be changed
* A requirement to modify update strategy settings
* A requirement to rollback to the previous revision

This question tests:

1. Your understanding of **Deployment strategy fields**
2. Your understanding of **revision history**
3. Your understanding of **what triggers a revision**
4. Your understanding of **what rollback actually reverts**

---

# **ğŸ“Œ Core Kubernetes Truth (Must Remember for Exam)**

## ğŸ¯ **Revision history is created ONLY when fields inside `spec.template` change.**

That includes:

* Container image
* Env variables
* Commands
* Args
* Labels in pod template
* Volume mounts
* Container probes
* Annotations (template-level)
* Security context (container-level)

### âŒ Fields *outside* `spec.template` do NOT create revisions:

* `spec.strategy`
* `spec.revisionHistoryLimit`
* `spec.minReadySeconds`
* `spec.progressDeadlineSeconds`
* `spec.selector`
* `spec.replicas`

---

# **ğŸ“Œ Rollback ONLY restores `spec.template`**

Rollback affects:

* image
* env
* labels
* mounts
* command/args

Rollback does NOT revert:

* strategy
* replicas
* selectors
* revisionHistoryLimit
* pause/resume status

This is why:

* You changed strategy â†’ revision **unchanged**
* You changed image in the same edit â†’ revision gets created
* Rollback restores image â†’ **strategy remains modified**

---

# **ğŸ“Œ Three Valid Ways to Solve the Question (Exam Accepts All)**

# **Method 1 â€” *Edit Twice* (Most Common Approach)**

### Step 1 â€” Change strategy

```
kubectl edit deployment app-deploy
```

Modify:

```yaml
spec:
  strategy:
    rollingUpdate:
      maxSurge: 50%
      maxUnavailable: 50%
```

ğŸ”¹ **NO revision created** because strategy is outside template.

---

### Step 2 â€” Update image

```
kubectl set image deployment app-deploy myapp=nginx:1.19
```

ğŸ”¹ **Revision created now**

---

### Step 3 â€” Rollback

```
kubectl rollout undo deployment app-deploy
```

âœ” Image goes back
âŒ Strategy does NOT revert

---

# **Method 2 â€” *Edit Once* (Combine Strategy + Image)**

```
kubectl edit deployment app-deploy
```

You modify both:

* Strategy
* Image

### What happens?

ğŸ”¹ A revision *is* created
ğŸ”¹ BUT rollback still restores **only the template (image)**
ğŸ”¹ Strategy still stays modified

ğŸ’¡ **Because strategy is not revision-controlled**

âœ” This method is faster
âœ” 100% valid in exam
âœ” Behavior same as Method 1

---

# **Method 3 â€” `kubectl patch`**

```
kubectl patch deployment app-deploy \
  -p '{"spec":{"strategy":{"rollingUpdate":{"maxSurge":"50%","maxUnavailable":"50%"}}}}'
```

ğŸ”¹ No revision

Then:

```
kubectl set image deployment app-deploy myapp=nginx:1.19
```

ğŸ”¹ Revision created

Rollback identical.

---

# **ğŸ“Œ EXAM TRAPS (Important)**

### **Trap 1 â€” Thinking strategy triggers revision**

âŒ It does not.
Only template changes trigger revision.

---

### **Trap 2 â€” Expecting rollback to revert strategy**

âŒ Strategy never rolls back.

Rollback only touches:
`spec.template` fields.

---

### **Trap 3 â€” Doing everything in one `kubectl edit` and expecting full revert**

Revert will:
âœ” Revert image
âŒ Not revert strategy
âŒ Not revert replicas
âŒ Not revert any spec outside template

---

### **Trap 4 â€” Forgetting rollout status**

Always check:

```
kubectl rollout status deployment app-deploy
```

---

# **ğŸ“Œ FINAL EXAM WORKFLOW (Guaranteed 100% Correct)**

### **Step-0: Check current revision**

```
kubectl rollout history deployment app-deploy
```

---

### **Step-1: Modify strategy**

```
kubectl edit deployment app-deploy
```

Add:

```yaml
spec:
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 5%
      maxUnavailable: 5%
```

---

### **Step-2: Update image**

```
kubectl set image deployment app-deploy app=nginx:1.19
```

---

### **Step-3: Verify rollout**

```
kubectl rollout status deployment app-deploy
```

---

### **Step-4: Undo**

```
kubectl rollout undo deployment app-deploy
```

---

### **Step-5: Verify again**

```
kubectl get deployment app-deploy -o yaml | grep strategy -A11
```

Image reverted â†’ âœ”
Strategy unchanged â†’ âœ”

---

# **ğŸ“Œ Intellectually Complete Conclusion**

1. You can change **strategy + image** together.
2. Revision will be created **only because image (template) changed**.
3. Rollback will **only revert template fields**.
4. Strategy will **remain changed**, no matter what.
5. Behavior is **identical** whether you edit all at once or separately.
6. Difference is only in rollout history description (`none` vs. â€œimage updatedâ€).

You understood this perfectly â€” this is expert-level CKA/CKAD knowledge.

---

```bash
controlplane ~ âœ  k create deploy abc --image nginx
deployment.apps/abc created

controlplane ~ âœ  k rollout history deploy abc
deployment.apps/abc 
REVISION  CHANGE-CAUSE
1         <none>


controlplane ~ âœ  k edit deploy abc                         # just spec.strategy is modified
deployment.apps/abc edited

controlplane ~ âœ  k rollout history deploy abc              # so, no revision triggered
deployment.apps/abc 
REVISION  CHANGE-CAUSE
1         <none>


controlplane ~ âœ  k edit deploy abc                         # this time, image is updated
deployment.apps/abc edited

controlplane ~ âœ  k rollout history deploy abc              # revision is triggered 
deployment.apps/abc 
REVISION  CHANGE-CAUSE
1         <none>
2         <none>


controlplane ~ âœ  k rollout undo deploy abc
deployment.apps/abc rolled back

controlplane ~ âœ  k rollout history deploy abc
deployment.apps/abc 
REVISION  CHANGE-CAUSE
2         <none>
3         <none>

controlplane ~ âœ  k get deploy -o yaml abc | grep -i strategy -A11
  strategy:                                                                  # presevered
    rollingUpdate:
      maxSurge: 5%
      maxUnavailable: 5%
    type: RollingUpdate
  template:
    metadata:
      labels:
        app: abc
    spec:
      containers:
      - image: nginx                                                          # reverted

controlplane ~ âœ  k delete deploy abc
deployment.apps "abc" deleted from default namespace

controlplane ~ âœ  k create deploy abc --image nginx
deployment.apps/abc created

controlplane ~ âœ  k rollout history deploy abc
deployment.apps/abc 
REVISION  CHANGE-CAUSE
1         <none>


controlplane ~ âœ  k edit deploy abc                                      # modified both in one flow
deployment.apps/abc edited

controlplane ~ âœ  k rollout history deploy abc                           # triggered, because image was updated
deployment.apps/abc 
REVISION  CHANGE-CAUSE
1         <none>
2         <none>

controlplane ~ âœ  k rollout undo deploy abc
deployment.apps/abc rolled back

controlplane ~ âœ  k rollout history deploy abc
deployment.apps/abc 
REVISION  CHANGE-CAUSE
2         <none>
3         <none>


controlplane ~ âœ  k get deploy -o yaml abc | grep -i strategy -A11              # same behavior 
  strategy:                                                                      # preserved
    rollingUpdate:
      maxSurge: 5%
      maxUnavailable: 5%
    type: RollingUpdate
  template:
    metadata:
      labels:
        app: abc
    spec:
      containers:
      - image: nginx                                                            # reverted

controlplane ~ âœ  
```
