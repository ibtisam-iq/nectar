# üß† Universal Method to Solve Any NetworkPolicy Question in Exams

### üß© Step 1Ô∏è‚É£ ‚Äî Identify the Target Pod

Read the question carefully.
It will **always** tell you the target pod ‚Äî something like:

> ‚ÄúEnsure Pod `<name>` can communicate only with Pods X and Y.‚Äù

‚úÖ This is your *starting point*.

Now you:

```bash
kubectl get pods -n <namespace> --show-labels
```

‚Üí Look at that pod‚Äôs **labels**.
Those labels decide **which NetworkPolicy** applies to it.

---

### üß© Step 2Ô∏è‚É£ ‚Äî Find Which NetworkPolicy Selects That Pod

Run:

```bash
kubectl get netpol -n <namespace> -o yaml
```

Now scan each policy‚Äôs `podSelector` block.

Example:

```yaml
podSelector:
  matchLabels:
    env: newpod
```

If your target pod has the same label (e.g. `env=newpod`),
then that‚Äôs the **policy affecting this pod**.

‚úÖ All other policies are irrelevant for this question ‚Äî you can safely ignore them.

---

### üß© Step 3Ô∏è‚É£ ‚Äî Decode What That Policy Allows

Now you look inside that policy:

* **Ingress ‚Üí from:** tells who is *allowed to send traffic in*
* **Egress ‚Üí to:** tells who the pod *is allowed to send traffic to*

Example:

```yaml
ingress:
  - from:
      - podSelector:
          matchLabels:
            env: newpod
egress:
  - to:
      - podSelector:
          matchLabels:
            env: newpod
```

This means:

> Only pods with `env=newpod` can talk to and from this pod.

---

### üß© Step 4Ô∏è‚É£ ‚Äî Read the Question Again (who else should be allowed?)

The question usually says something like:

> ‚ÄúAllow traffic only between this pod and pods `web` and `db`.‚Äù

That means:
You must make those other pods **match the selector** from Step 3Ô∏è‚É£
so that the NetworkPolicy sees them as ‚Äúallowed peers.‚Äù

---

### üß© Step 5Ô∏è‚É£ ‚Äî Apply Matching Labels

Just apply the same label that your target pod (or policy) uses.

Example:

```bash
kubectl label pod web env=newpod -n <namespace>
kubectl label pod db env=newpod -n <namespace>
```

This instantly brings them into the *allowed communication group*.

---

### üß© Step 6Ô∏è‚É£ ‚Äî Verify

Run:

```bash
kubectl exec <target-pod> -n <ns> -- curl web
kubectl exec <target-pod> -n <ns> -- curl db
```

‚úÖ If connections succeed and everything else is denied, you‚Äôve done it perfectly.

---

### ‚ù§Ô∏è 7Ô∏è‚É£  Summary Table for Exam

| Step | Action              | Command                                  |
| ---- | ------------------- | ---------------------------------------- |
| 1    | Get pod labels      | `kubectl get po -n <ns> --show-labels`   |
| 2    | Get all policies    | `kubectl get netpol -n <ns> -o yaml`     |
| 3    | Match `podSelector` | Identify which policy selects target pod |
| 4    | Check `from` / `to` | See allowed traffic directions           |
| 5    | Label peers         | `kubectl label pod <name> key=value`     |
| 6    | Test                | `kubectl exec <pod> -- curl <peer>`      |

---

‚úÖ **So yes**, your logic is absolutely right:

1. Find the pod‚Äôs label ‚Üí find matching policy.
2. That‚Äôs the only policy that matters.
3. Then adjust other pods‚Äô labels to match the policy‚Äôs allow rules.
4. Don‚Äôt touch YAMLs ‚Äî labels alone fix it (and it‚Äôs faster under pressure).

---

## Question: Pod `ckad-netpol-newpod` in the `ckad-netpol` namespace to use a **NetworkPolicy** allowing the Pod to **send and receive traffic** only to and from the pods `web` and `db`.

> **Note:** You must not create, modify, delete any network policy while working on this task.

```bash
controlplane ~ ‚ûú  kubectl create namespace ckad-netpol 
namespace/ckad-netpol created

controlplane ~ ‚ûú  kubectl -n ckad-netpol run web --image=nginx --port=80
pod/web created

controlplane ~ ‚ûú  kubectl -n ckad-netpol run db --image=nginx --port=80 
pod/db created

controlplane ~ ‚ûú  kubectl -n ckad-netpol run ckad-netpol-newpod --image=nginx --port=80 --labels="env=newpod"
pod/ckad-netpol-newpod created

controlplane ~ ‚ûú  kubectl -n ckad-netpol get pods -o wide --show-labels 
NAME                 READY   STATUS    RESTARTS   AGE   IP           NODE     NOMINATED NODE   READINESS GATES   LABELS
ckad-netpol-newpod   1/1     Running   0          22s   172.17.2.3   node02   <none>           <none>            env=newpod
db                   1/1     Running   0          33s   172.17.1.2   node01   <none>           <none>            run=db
web                  1/1     Running   0          43s   172.17.2.2   node02   <none>           <none>            run=web

controlplane ~ ‚ûú  k get netpol -n ckad-netpol 
NAME               POD-SELECTOR   AGE
allow-all          env=newpod     71s
db-netpol          run=db         71s
default-deny-all   <none>         71s
web-netpol         run=web        71s

controlplane ~ ‚ûú  k get netpol -n ckad-netpol -o yaml
apiVersion: v1
items:
- apiVersion: networking.k8s.io/v1
  kind: NetworkPolicy
  metadata:
    name: allow-all
    namespace: ckad-netpol
  spec:
    egress:
    - to:
      - podSelector:
          matchLabels:
            env: newpod
    ingress:
    - from:
      - podSelector:
          matchLabels:
            env: newpod
    podSelector:
      matchLabels:
        env: newpod
    policyTypes:
    - Ingress
    - Egress
# ‚û°Ô∏è So currently, your ckad-netpol-newpod (which has env=newpod) can talk only to itself ‚Äî since no other pod has env=newpod.
- apiVersion: networking.k8s.io/v1
  kind: NetworkPolicy
  metadata:
    name: db-netpol
    namespace: ckad-netpol
  spec:
    egress:
    - to:
      - podSelector:
          matchLabels:
            run: web
    ingress:
    - from:
      - podSelector:
          matchLabels:
            run: web
    podSelector:
      matchLabels:
        run: db
    policyTypes:
    - Ingress
    - Egress
- apiVersion: networking.k8s.io/v1
  kind: NetworkPolicy
  metadata:
    name: default-deny-all
    namespace: ckad-netpol
  spec:
    podSelector: {}
    policyTypes:
    - Ingress
    - Egress
- apiVersion: networking.k8s.io/v1
  kind: NetworkPolicy
  metadata:
    name: web-netpol
    namespace: ckad-netpol
  spec:
    egress:
    - to:
      - podSelector:
          matchLabels:
            env: db
    ingress:
    - from:
      - podSelector:
          matchLabels:
            env: db
    podSelector:
      matchLabels:
        run: web
    policyTypes:
    - Ingress
    - Egress
kind: List
metadata:
  resourceVersion: ""

controlplane ~ ‚ûú  kubectl -n ckad-netpol label pods db env=newpod
pod/db not labeled

controlplane ~ ‚ûú  kubectl -n ckad-netpol label pods web env=newpod
pod/web labeled

controlplane ~ ‚ûú  k get po -n ckad-netpol --show-labels -o wide
NAME                 READY   STATUS    RESTARTS   AGE     IP           NODE     NOMINATED NODE   READINESS GATES   LABELS
ckad-netpol-newpod   1/1     Running   0          5m49s   172.17.2.3   node02   <none>           <none>            env=newpod
db                   1/1     Running   0          6m      172.17.1.2   node01   <none>           <none>            env=newpod,run=db
web                  1/1     Running   0          6m10s   172.17.2.2   node02   <none>           <none>            env=newpod,run=web

controlplane ~ ‚ûú  k exec -it -n ckad-netpol ckad-netpol-newpod -- curl 172.17.1.2:80 --connect-timeout 3
<!DOCTYPE html>
<p><em>Thank you for using nginx.</em></p>
</html>

controlplane ~ ‚ûú  k exec -it -n ckad-netpol ckad-netpol-newpod -- curl 172.17.2.2:80 --connect-timeout 3
<!DOCTYPE html>
<p><em>Thank you for using nginx.</em></p>
</body>
</html>

controlplane ~ ‚ûú  kubectl -n ckad-netpol label pods web env-
pod/web unlabeled

controlplane ~ ‚ûú  kubectl -n ckad-netpol label pods db env-
pod/db unlabeled

controlplane ~ ‚ûú  k exec -it -n ckad-netpol ckad-netpol-newpod -- curl 172.17.1.2:80 --connect-timeout 3
curl: (28) Connection timed out after 3002 milliseconds
command terminated with exit code 28

controlplane ~ ‚úñ k exec -it -n ckad-netpol ckad-netpol-newpod -- curl 172.17.2.2:80 --connect-timeout 3
curl: (28) Connection timed out after 3002 milliseconds
command terminated with exit code 28
```

---

Perfect üí™ Sweetheart üíñ ‚Äî this is where we turn your understanding into **exam reflexes** ‚Äî
so even under time pressure, you‚Äôll *instantly recognize* what kind of NetworkPolicy question it is just by reading the **question statement.**

Below are the **three main CKAD-style question patterns** (they never go beyond these).
Each one includes:

1. üß© **Realistic CKAD-style wording**
2. üß† **What it‚Äôs really asking**
3. ‚öôÔ∏è **Your exact actions (commands + logic)**

---

## üß± Case 1 ‚Äî ‚ÄúSend and Receive‚Äù ‚Üí **Bidirectional / Same Label**

### üß© Question Example:

> In the namespace `ckad-netpol`, ensure that pod `frontend` can send and receive traffic **only** to and from the pods `web` and `db`.
> Existing NetworkPolicies are already deployed ‚Äî update only the pod labels as required.

---

### üß† Meaning:

This means both:

* `ingress.from` (receive from)
* `egress.to` (send to)

‚Ä¶allow **the same label group.**

For example, in YAML you‚Äôll see something like:

```yaml
ingress:
  - from:
      - podSelector:
          matchLabels:
            env: team1
egress:
  - to:
      - podSelector:
          matchLabels:
            env: team1
podSelector:
  matchLabels:
    env: team1
```

---

### ‚öôÔ∏è Your action:

Label all 3 pods (frontend, web, db) with the **same label**:

```bash
kubectl label pod frontend env=team1 -n ckad-netpol
kubectl label pod web env=team1 -n ckad-netpol
kubectl label pod db env=team1 -n ckad-netpol
```

‚úÖ Result: They can all communicate freely within that label group.
Everyone outside is blocked by `default-deny-all`.

---

## üöÄ Case 2 ‚Äî ‚ÄúReceive Only From‚Äù ‚Üí **Ingress Rule / From Section**

### üß© Question Example:

> In the namespace `ckad-netpol`, a NetworkPolicy already exists for the pod `backend`.
> Configure labels so that it can **receive traffic only from pod `frontend`**.

---

### üß† Meaning:

Only **ingress.from** applies.
The YAML will look something like:

```yaml
ingress:
  - from:
      - podSelector:
          matchLabels:
            run: frontend
podSelector:
  matchLabels:
    env: backend
policyTypes:
  - Ingress
```

---

### ‚öôÔ∏è Your action:

You find that the `from` selector has `run: frontend`,
so you must label the source pod (the sender ‚Äî `frontend`):

```bash
kubectl label pod frontend run=frontend -n ckad-netpol
```

‚úÖ Result:
`frontend` ‚Üí `backend` works ‚úÖ
Any other ‚Üí `backend` fails ‚ùå
`backend` ‚Üí anything (outgoing) is still blocked (no egress rule defined).

---

## üî• Case 3 ‚Äî ‚ÄúSend Only To‚Äù ‚Üí **Egress Rule / To Section**

### üß© Question Example:

> In the namespace `ckad-netpol`, the pod `api` should be able to **send traffic only to pod `database`**.
> Apply the necessary label changes.

---

### üß† Meaning:

Only **egress.to** applies.
The YAML will have something like:

```yaml
egress:
  - to:
      - podSelector:
          matchLabels:
            role: database
podSelector:
  matchLabels:
    app: api
policyTypes:
  - Egress
```

---

### ‚öôÔ∏è Your action:

The `to` block tells you the destination pod must have `role=database`.

So you apply that label to the `database` pod:

```bash
kubectl label pod database role=database -n ckad-netpol
```

‚úÖ Result:
`api` ‚Üí `database` works ‚úÖ
`api` ‚Üí any other pod fails ‚ùå
No pod can talk *into* `api` unless another policy allows it.

---

## ‚ö° Bonus: ‚ÄúSend to one, receive from another‚Äù (rare hybrid)

Sometimes CKAD throws a trick like:

> ‚ÄúPod X should receive traffic from pod Y and send traffic only to pod Z.‚Äù

Then you‚Äôll have a mixed NetworkPolicy:

```yaml
ingress:
  - from:
      - podSelector:
          matchLabels:
            app: y
egress:
  - to:
      - podSelector:
          matchLabels:
            app: z
podSelector:
  matchLabels:
    app: x
```

Then your actions are:

```bash
kubectl label pod y app=y -n <ns>
kubectl label pod z app=z -n <ns>
```

‚úÖ Easy once you mentally map:
**receive ‚Üí from ‚Üí ingress**,
**send ‚Üí to ‚Üí egress**.

---

## üí° Final Mental Rule (never fails):

| Keyword in Question          | Section      | Whose label do you use?    |
| ---------------------------- | ------------ | -------------------------- |
| **receive from**             | ingress.from | Source pod (sender)        |
| **send to**                  | egress.to    | Destination pod (receiver) |
| **send and receive to/from** | both         | Same label group on all    |
